Part 3-1 強化-函數式編程思想

! return返回單個對象，yield返回多個對象

exercise01,common(package)裡面的Iterable_tool

////////////////////////////////////////////////////////////////////////////////////////////////////////////
Part 3-2 lambda表達式

*** lambda是匿名方法，lambda不支持賦值語句，不支持多條語句
	lambda的作用是作為方法的實參傳入

    def func01(a,b):
	return a > b

    # 上面的func01等於下面lambda表達式子
    lambda a,b: a > b

## lambda 
    
    語法:
	lambda 參數:方法體

    lambda可以不寫參數，不傳參數; 也可以傳參，不寫參...
	lambda :print("你好")

    作用:
	作為參數傳遞時語法簡潔，優雅，代碼可讀性強。
	隨時創建和銷毀，減少程序耦合



    用1~5步驟寫:
        1. 根據需求，定義函數。
        2. 將變化點單獨定義為函數。
        3. 將通用代碼定義為函數(使用參數隔離變化點)
        4. 在IterableHelper類中添加新功能
        5. 在當前模塊中進行測試

exercise01 練習二、三，在裡面把條件替換成lambda

////////////////////////////////////////////////////////////////////////////////////////////////////////////
Part 3-3 強化-lambda表達式

* lambda 只能做簡單的return和直接的動作，不能做判斷，所以判斷要在別的函式
	 再把函數傳到函數裡

* lambda 參數(可迭帶對象裡面的每個元素): 方法體(回傳的東西)SS



    用4~5寫步驟: (lambda取代1~3)
        1. 根據需求，定義函數。
        2. 將變化點單獨定義為函數。
        3. 將通用代碼定義為函數(使用參數隔離變化點)
        4. 在IterableHelper類中添加新功能
        5. 在當前模塊中進行測試

exercise01 練習四、五、六，iterable_tool

////////////////////////////////////////////////////////////////////////////////////////////////////////////
Part 3-4 內置高階函數

# 內置高階函數定義: 這個函數的參數或者返回值是函數

    函數可以用lambda去寫

	* map(函數, 可迭代對象):  映射
		作用  :使用可迭代對象中的 '每個元素調用函數'
		返回值: 新可迭代對象 (將返回值作為 新可迭代對象 元素)
		類似於: iterable_tool裡面的 select()

	* filter(函數, 可迭代對象):
		作用  : 根據條件篩選可迭代對象中的元素
		返回值: 新可迭代對象
		類似於: iterable_tool裡面的 find_all()

	* sorted(可迭代對象, key = 函數, reverse = bool值):  reverse = true 升序， false 降序
		注意  : 沒有改變原有列表，而是返回新的
		作用  : 排序
		返回值: 排序結果
		類似於: iterable_tool裡面的 select()

	* max(可迭代對象, key = 函數):           這裡的key是使用關鍵字實參
		根據數據獲取可迭代對象的最大值
		類似於: iterable_tool裡面的 get_min()

	* min(可迭代對象, key = 函數):
		根據數據獲取可迭代對象的最小值
		類似於: iterable_tool裡面的 order_by()


*** 刪除可迭代對象是倒著刪，如果正的刪會因為前面的被刪掉而導致後面元素的索引跑掉
	for i in range(len(iterable)-1, -1, -1):
	    del iterable[i]

*** 字典.item()可以把字典裏面的鍵和值放到 列表中的 元組裡，可以取出鍵(item[0])和值(item[1])


exercise01 練習七、八，iterable_tool，exercise02

////////////////////////////////////////////////////////////////////////////////////////////////////////////
Part 3-5 函數作為返回值

## 作用域
    Local 局部作用域: 函數內部。
    Enclosing 外部嵌套作用域: 函數嵌套。 (內部函數可以訪問外部函數區域變量)
	如果內部函數要改外部函數的值，不是用global，是用nonlocal 變量 = ?
    Global 全局作用域: 模塊(.py文件)內部。
    Builtin 內置模塊作用域: builtins.py文件。

## 閉包: 字面意思: 封閉程序運行環境 --> 保存。 對於沒有面相對象的語言，這個用來取代面向對向
    三大要素:
	1. 具有內外函數
	2. 內部函數訪問外部函數變量
	3. 外部函數返回內部函數

    本質: 閉包是將內部函數和外部函數的執行環境綁定在一起的對象。

    定義: 在一個函數內部的函數，同時內部函數又引用了外部函數的變量。
	def 外部函數名(參數):
	    外部變量
	    def 內部函數名(參數):
		使用外部變量
	    return 內部函數名  (沒有小誇號)
    
    調用:
	變量 = 外部函數名(參數)
	變量(參數) --> 調用內部函數

    體現:
	外部函數執行過後，棧禎沒有釋放，等待內部函數使用

    優點:
	內部函數可以使用外部變量
    缺點:
	外部變量一直存在於內存中，不會在調用結束後釋放，佔用內存

    作用:
	邏輯連續，當內部函數被調用時，不脫離當前的邏輯。
	實現python裝飾器。

    EX:
	def func01():
	    a = 100
	    def func02():
	    	print(a)
	    return func02

        # 調用外部函數，返回內部函數
	result = func01

	# 因為python支持閉包，所以在外部函數執行過後，棧禎沒有釋放
	# 因此內部函數執行時，可以正確放問外部嵌套變量
	result()

exercise03

////////////////////////////////////////////////////////////////////////////////////////////////////////////
Part 3-6 裝飾器

@property是內置裝飾器，原理跟下面要講得差不多

### 函數裝飾器

    定義:
	在不改變原函數的調用以及內部代碼情況下，為其添加新功能的函數。

    核心邏輯: 攔截

    裝飾器推導原理: exercise04

    語法:
	def 函數裝飾器名稱(func):
	     def 內嵌函數(*args, **kwargs):  # 合成tuple
		需要添加的新功能
		return func(*args, **kwargs)  # 拆 tuple
	    return wrapper

    本質:
	使用 "@函數裝飾器名稱" 修飾原函數，等同於創建與原函數名稱相同的變量，
	關聯內嵌函數；故調用原函數時執行內嵌函數。
	--> 原函數名稱 = 函數裝飾器名稱  # @函數裝飾器名稱

    裝飾器鏈:
	一個函數可以被多個裝飾器修飾，執行順序為從近到遠。
	@func02  # 遠
	@func01  # 近
	func():
	    pass



exercise03

////////////////////////////////////////////////////////////////////////////////////////////////////////////
### 總結

### 函數式編程
	函數作為參數:
	    lambda、 內置高階函數
	
	函數作為返回值:
	    閉包、 裝飾器
