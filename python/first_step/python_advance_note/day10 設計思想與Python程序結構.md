Part 1-1 強化-設計原則

### 六大設計原則

    1. 開閉原則 (目標、總的指導思想)
    2. 類的單一職責 (一個類的定義)
    3. 依賴導致 (依賴抽象)
    4. 組合復用原則 (復用的最佳實踐)

    5. 里氏替換 (繼承後的重寫，指導繼承的設計)
	Liskov Substitution Principle
	父類出現的地方可以被子類替換，在替換後依然保持原功能。
	子類要擁有父類的所有功能。
	子類在重寫父類方法時，盡量選擇擴展重寫(super.)，防止改變了功能。

    6. 迪米特法則 (類與類交互的原則) --> 隔離
	Law of Demeter
	不要和陌生人說話。
	類與類交互時，在滿足功能要求的基礎上，傳遞的數據量越少越好，因為這樣可能降低偶合度

exercise01

////////////////////////////////////////////////////////////////////////////////////////////////////////
Part 1-2 技能系統


exercise03
把多個技能的"效果"分成多個類，用一個父類整合他們
建立一個配置文件儲存技能資料
用技能釋放器打出技能
	1. 讀取配置文件
	2. 技能數據讀取 (建創一個類，可以對應到配置文件)
	3. 建創相應效果 (讀取父類)
	4. 釋放技能

# 多繼承
	繼承: 統一概念/隔離變化
	同名方法解析順序 mro

class A:
    def func(self): print("A")
        
class B(A):
    def func(self): print("B")
        
class C(A):
    def func(self): print("C")
        
class D(B, C):
    def func(self):
        print("D")
        super().func()# B
        C.func(self)# 调用指定名称的父类同名方法

d01 = D()
d01.func()  # D /n B /n C

print(D.mro())  # [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]


   3
1     2   # 調用順序
   0


exercise03(老師寫我複製)

////////////////////////////////////////////////////////////////////////////////////////////////////////
Part 1-3 模塊

*** 要import文件時，可以先把文件所在資料夾左鍵 --> Mark Directory as --> Sources Root
	這樣可以讓文件導入時，內容有提示，方便，快速

模塊 (Module)
    定義:
	包含一系列數據、函數、類的文件，通常以.py結尾

    作用: 
	讓一些相關的數據、函數、類，有邏輯的組織在一起，使邏輯結構更加清晰，
	有利於多人合作開發

    導入:
	導入方式1: import 模塊名
	使用: 模塊名.成員
	本質: 創建變量關聯模塊地址
	適用性: 面相過程的函數、全局變量

	導入方式1: from 模塊名 import 成員
	使用: 直接使用成員
	本質: 將其他模塊成員導入到當前作用域中 (小心命名衝突)
	適用性: 面相對象的類

	導入方式2: from 模塊名 import *
	使用: 直接使用成員，全部導入
	本質: 將其他模塊成員導入到當前作用域中 (小心命名衝突)
	適用性: 面相對象的類

** 其他文件被導入時，會生成pyc(第一天有說到)文件，而入口不會生成，所以需要代碼最少

exercise04
project_month01/manager_system

////////////////////////////////////////////////////////////////////////////////////////////////////////
Part 1-4 包
跟模塊差不多的技術，只是換了名詞而已

包 (package):
    定義: 
	將模塊以文件夾的形式進行分組管理
	
    作用:
	讓一些相關的模塊組織在一起，使邏輯結構更加清晰

    導入:
	導入方式1: import 路徑.模塊名
	使用: 路徑.模塊名.成員
	導入方式1.5:i mpott 路徑.模塊名 as 別名
	使用: 別名.成員

	導入方式2: from 路徑.模塊名 import 成員
	使用: 直接使用成員

	導入方式3: from 路徑.模塊名 import *
	使用: 直接使用成員，全部導入

 
    作用:
	將某模塊整體導入到當前模塊


* 包裡面都會有__init__.py文件，表示他是一個包，也可以在裡面寫代碼，讓某些文件可以被導入(__all__)
* 不管資料夾多近，都從根目錄開始調用 (啟動的那個文件上面的資料夾就是根目錄)

*** 導入是否成功得條件:
	系統路徑 + 導入路徑 == 真實路徑
	系統路徑是一個列表，裡面放很多預設路徑，如果第一個失敗就取第二個，第二個失敗就第三...

可以導入系統看路徑:
	import sys
	print(sys.path)
    如果系統找不到路徑可以幫他 '加'
	sys.path.append("路徑")

exercise05
myproject

////////////////////////////////////////////////////////////////////////////////////////////////////////
Part 1-5 模塊相關觀念

# 模塊變量:
	* __all__變量: 定義可導出成員，僅對from xx import * 語句有效。
			通常是在__init__.py文件裡放入，像: __all__ = ["skill_manager"]
	* __doc__變量: 文黨字符串，顯示註釋的文字，什麼都可以用這個。
	* __file__變量: 模塊對應的文件路徑名。
**      * __name__變量: 模塊自身名字，可以判斷是首否為主模塊
		當此模塊作為主模塊(第一個運行的模塊)運行時，__name__綁定'__main__'，
		不是主模塊，而是被其他模塊導入時，存儲模塊名，通常用於下列方式
		# 如果當前是主模塊，才執行後續邏輯
		if __name__ == "__main__"
		    /.....

# 模塊加載過程:
	在模塊導入時，模塊的所有語句會執行
	如果一個模塊已經導入，再次導入不會重複執行

# 模塊分類:
    * 內置模塊(builtins): 在解析器的內部，可以直接使用
    * 標準庫模塊: 安裝Python時已安裝且可以導入再直接用
    * 第三方模塊(通常為開源): 需要自己安裝
    * 用戶自己編寫的模塊 (可做為其他人的第三方模塊) 

# 模塊搜索順序:
    * 搜索內建模塊(builtins)
    * sys.path(系統路徑) 提供的路徑，通常第一個是主模塊所在目錄。

# 內建時間處理模塊
	import time
	
	# 1. 獲取當前時間戳: 從19701月1日到現在經過的秒數
	print(time.time())

	# 2. 獲取當前時間元組 (年、月、日、時、分、秒、星期、年的第幾天、夏令時)
	print(time.localtime())

	# 3. 時間戳 --> 時間元組
	print(time.localtime(time.time()))
	
	# 4. 時間元組 --> 時間戳
	print(time.mktime(time.localtime()))

	# 5. 時間元組 --> 字符串
	print(time.strftime("%y %m %d %H %M %S", time.localtime())) # 格式可以自訂，小y是21大Y是2021

	# 6. 字符串 --> 時間元組
	print(time.strptime("19/12/17 23:17:23","%y/%m/%d %H:%M:%S"))

exercise06~07

////////////////////////////////////////////////////////////////////////////////////////////////////////
Part 1-6 異常處理

# 常見異常類型
 
    * 名稱異常 (NameError): 變量未定義
    * 類型異常 (TypeError): 不同類型數據進行運算
    * 索引異常 (IndexError): 超出索引範圍
    * 屬性異常 (AttributeError): 對象沒有對應名稱的屬性
    * 鍵異常 (KeyError): 沒有對應名稱的鍵
    * 異常基類 (Exception):

	現象: 當異常發生時，程序不會再向下執行，而轉到函數的調用語句
	處理 --> 作用: 將程序由異常狀態轉為正常流程

	語法:
	    try:
		可能觸發異常的語句
	    except 錯誤類型1:
		處理語句1
	    
	    except Exception:
		不是以上錯誤類型的處理語句，也可以單寫except
	
	    else:
		未發生異常的語句(沒錯就做)
	    finally:
		無論是否發生異常的語句(沒有except時，才有用，必須要用的處理--> 打開   finally  關閉)

* 系統報錯錯的通常都在最後一個


exercise08

